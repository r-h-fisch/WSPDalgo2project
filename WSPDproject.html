<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Well-Separated Pair Decompositions (WSPD)</title>
  
 <link rel="stylesheet" href="WSPDmain.css">
</head>

<body>

  <link href='https://fonts.googleapis.com/css?family=Lora' rel='stylesheet' type='text/css'>
<div class="everything">
<div class="header">
  <h1 class="title"></h1>
  
  <ul class="links">
    <li class="current"><a href="">Top</a></li>
    <li><a href="">Definition</a></li>
    <li><a href="">Quadtree</a></li>
    <li><a href="">Building the sWSPD from a QUADTREE</a></li>
    <li><a href="">Packing Argument</a></li>
    <li><a href="">Application of sWSPD on Spanners</a></li>
    <li><a href="">Works Cited</a></li>
  </ul>
</div>

<div class="right">
  <div class="content">
    <div class="post">
      <h3 class="post-title"><a href="">Quick Glance</a></h3>
      <div class="post-content">
        <p>A sWSPD for P is a partition of the (n choose 2) edges of the complete graph on P into a collection of m well-separated pairs. Given two point sets A and B and a constant  0 < s < 1, we say (A, B) is s-separated if: max{diam(A), diam(B)} ≤ s∗dist(A, B) where dist(A, B)= min(a,b) ∈A×B‖a − b‖.</p>
         <img src="introimage1.jpg" style="width:480px;height:270px;">

      </div>
    </div>
    
     <div class="post">
      <h3 class="post-title"><a href="">Quadtree</a></h3>
      <div class="post-content">
           <img src="https://media.giphy.com/media/RJbjlHL49iLS7awjB2/giphy.gif">
           <img src="https://media.giphy.com/media/h6l1soXTasLR3B2t1P/giphy.gif">


      </div>
    </div>

    <div class="post">
      <h3 class="post-title"><a href="">DEFINITION OF sWSPD</a></h3>
      <div class="post-content">
        <p> Δu = diameter of node u <br>
            Δv = diameter of node v <br>
            ▢u = set of leaves in node u <br>
            ▢v = set of leaves in node v <br>
            F = created s-WSPD <br>

            First call of the function is: WSPD(root, root)</p>

      <pre>
WSPD(u, v)
{
  if ∆u < ∆v
    swap(u, v)
    if ∆u ≤ sd(▢u,▢v)
     F = F ∪{(u,v)}
  else
    for each child w of u 
      WSPD(w, v)
}
</pre>
      </div>
    </div>
        <div class="post">
      <h3 class="post-title"><a href="">Building the sWSPD from a QUADTREE</a></h3>
      <div class="post-content">
        <p> Δu = diameter of node u <br>
            Δv = diameter of node v <br>
            ▢u = set of leaves in node u <br>
            ▢v = set of leaves in node v <br>
            F = created s-WSPD <br>

            First call of the function is: WSPD(root, root)</p>

      <pre>
WSPD(u, v)
{
  if ∆u < ∆v
    swap(u, v)
    if ∆u ≤ sd(▢u,▢v)
     F = F ∪{(u,v)}
  else
    for each child w of u 
      WSPD(w, v)
}
</pre>
      </div>
    </div>
      <div class="post">
<<<<<<< HEAD
      <h3 class="post-title"><a href="">Packing Arguement</a></h3>
=======
      <h3 class="post-title"><a href="">Packing Argument</a></h3>
>>>>>>> RebeccaChanges
      <div class="post-content">
        <p>Algorithm uses a packing argument to divide up the nodes of the quadtree into s-WSPD. The number of circles of size Δ that are at k away from a given point is O(k^2/Δ^2) or in our case O(1/s^2)</p>
        <p> A circle packing is an arrangement of circles inside a given boundary such that no two overlap and some (or all) of them are mutually tangent. The generalization to spheres is called a sphere packing. Tessellations of regular polygons correspond to particular circle packings (Williams 1979, pp. 35-41). There is a well-developed theory of circle packing in the context of discrete conformal mapping (Stephenson). </p>
        <p> for more cool visualizations of circle packing see this link: http://lramrz.com/2017/01/circle-packing-in-processing/</p>

      <img src="http://learningfromdogs.files.wordpress.com/2010/09/dog-alpaca.png?w=700">
        <p>Damnit I love alpacas. So cute. This one is friends with a dog.</p>
      </div>
    </div>
    
    
    <div class="post">
      <h3 class="post-title"><a href="">Application of sWSPD on Spanners</a></h3>
      <div class="post-content">
        <p> A spanner is a small-size graph such that the shortest path distance between any two points is roughly their Euclidean distance.<br><br>
        <b>Definition.</b> A graph G = (S, E) is a ε-spanner if <br> 
        <center>∀p,q ∈ S, dG(p,q) ≤ (1+ε)∥p−q∥.</center><br> 
        <b>Theorem.</b><br> 
        ∀s>0, in two dimensional space an s-spanner on S of size O(n) can be constructed in O(nlogn + n/(s^2)) time. <br>
        <b>Proof.</b><br>
        Set δ = s/16. Construct δ-WSPD F for S. For each pair (Ai,Bi) ∈ F, choose (pi,qi) ∈ Ai×Bi.
        Let E = {(pi, qi) | 1 ≤ i ≤ |F|}. We use induction on the (n choose 2) distances to show that G = (S, E) is an s-spanner.</p>
        <img src = “spanner_diagram.png”>
        <p> <center> dG(p, q) = dG(p, pi) + ∥pi, qi∥ + dG(q, qi)</center><br>
        By the property of δ-WSPD,<br>
        <center> ∥p−pi∥ ≤ δ∥pi − qi∥. </center><br>
        By the inductive hypothesis,<br>
        <center>dG(p,pi)≤(1+s)∥p−pi∥≤(1+s)δ∥pi−qi∥</center><br>
        Similarly, (1+s)∥q−qi∥≤(1+s)δ∥pi−qi∥. By triangle inequality,
        <br><br>
        <center>∥pi−qi∥ ≤ ∥p−q∥ + ∥p−pi∥ + ∥q−qi∥ ≤ ∥p−q∥ + 2δ∥p−q∥ = (1+2s)∥p−q∥</center><br>
        Since δ ≤ s/16 ,it can be argued that ∥p−pi∥ < ∥p−q∥. Therefore 
        <br><br>
        <center>dG(p, q) ≤ dG(p, pi) + dG(q, qi) + ∥pi − qi∥</center><br>
        <center> ≤ 2(1+s)δ∥pi − qi∥ + ∥pi − qi∥ </center><br>
        <center>≤ (1+2(1+s)δ)(1+2δ)∥p − q∥ </center><br>
        <center>dG(p, q) ≤ (1 + s) ∥p − q∥</center><br>
        <center>Q.E.D.</center></p>

      </div>
    </div>

    <div class="footer">
     Rebecca and Sofiia 
    </div>
  </div>
  </div>
</div>
  <script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>

  

</body>

</html>
