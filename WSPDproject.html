<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Well-Separated Pair Decompositions (WSPD)</title>
  
 <link rel="stylesheet" href="WSPDmain.css">
</head>

<body>

  <link href='https://fonts.googleapis.com/css?family=Lora' rel='stylesheet' type='text/css'>
<div class="everything">
<div class="header">
  <h1 class="title"></h1>
  
  <ul class="links">
    <li class="current"><a href="#top">Top</a></li>
    <li><a href="#Definition">Definition</a></li>
    <li><a href="#quadtree"> Point-Region Quadtree</a></li>
    <li><a href="#buildingWSPD">Building the sWSPD from a QUADTREE</a></li>
    <li><a href="#packing">Packing Argument</a></li>
    <li><a href="#Application">Application of sWSPD on Spanners</a></li>
    <li><a href="">Works Cited</a></li>
  </ul>
</div>

<div class="right">
  <div class="content">

      <div class="post"  id="top">
      <h3 class="post-title"><a >Quick Overview</a></h3>
      <div class="post-content">
       <p> Paul B. Callahan and S. Rao Kosaraju devised the well-separated pair decomposition (WSPD). They showed that it can be used to solve a variety of distance problems. A WSPD is a partition of the (n over 2) edges of the complete Euclidean graph into O(n) subsets. Each subset in this partition is represented by two subsets A and B of the point set S, such that:
        <ol>
        <li> All distances between points in A and points in B are approximately equal </li>
        <li> All distances within the point set A are much smaller than distances between A and B </li>
         <li> All distances within the point set B are much smaller than distances between A and B. </li>
      </ol>
        Thus, a WSPD can be regarded as a set of O(n) edges that approximates the dense complete Euclidean graph. 
        <br>
      </p>
       <img src="blankintroimage.jpg" style="width:480px;height:270px;">
      <p>
        The WSPD can be used to obtain many optimal algorithms for solving problems such as: closest pair problem, the k-closest pairs problem, the all-nearest neighbors problem, and the approximate minimum spanning tree problem. On this site, we will mainly focus on the details of the WSPD and its application with reguards to constructing spanners. </p>
      </div>
    </div>

    <div class="post" id = "Definition">
      <h3 class="post-title" ><a>Definition of WSPD</a></h3>
      <div class="post-content">
        <p>A sWSPD for P is a partition of the (n choose 2) edges of the complete graph on P into a collection of m well-separated pairs. Given two point sets A and B and a constant  0 < s < 1, we say (A, B) is s-separated if: max{diam(A), diam(B)} ≤ s∗dist(A, B) where dist(A, B)= min(a,b) ∈A×B‖a − b‖.</p>
         <img src="introimage1.jpg" style="width:480px;height:270px;">

      </div>
    </div>
    
     <div class="post" id="quadtree">
      <h3 class="post-title"><a >Point-Region Quadtree</a></h3>
      <div class="post-content">
        <p>
          In the <b>Point-Region quadtree </b> (PR quadtree) each node either has exactly four children or is a leaf. The PR quadtree represents a collection of data points in two dimensions by decomposing the region containing the data points into four equal quadrants, subquadrants, and so on, until no leaf node contains more than a single point.
        </p>
        <img src="https://media.giphy.com/media/RJbjlHL49iLS7awjB2/giphy.gif">
        <img src="https://media.giphy.com/media/h6l1soXTasLR3B2t1P/giphy.gif">
        <br>
        <p>
          For the purpose of constructing sWSPD we use a <b>compressed PR quadtree</b> that can be constructed in <u><b>O(nlogn)</b></u>. 
          <br><br>
          A compressed PR quadtree is a quadtree that has two types of nodes: <b>compressed and uncompressed</b>. 
          <ul>
            <li><b>Compressed</b> nodes have a single child and represent the area of the quadrant around their child.</li>
            <li><b>Uncompressed</b> nodes are either leaves or split the pointset in their square into two or more subsets.</li>
          </ul>
          Compressed trees have <b>linear size</b>.<br><br>
          <u><b>Construction of a quadtree on a set of points P:</b></u><br><br>
          Set k = |P|/10. Construct a disk D with a radius r such that D contains at least k points of the set P and<br> 
          <center>r(opt)(P, k) ≤ r ≤ 2r(opt)(P, k).</center><br>
          Let l = 2^(floor(log(r))) ≥ r/2. Compute a grid with the length of a side of each cell equal to l. 
          Find a cell c with the maximum number of points inside of it.<br><br>
          <center>P(in) = P ∩ c, P(out) = P \ c.</center><br>
          <center>l ≥ r/2 ⇒ |P(in)| ≥ k/25 = |P|/250. </center><br>
          <center>l ≤ 2 r(opt)(P,k) ⇒ |P(in)| ≤ 4|P|/5.</center> <br>
          Recursive call on P(in) and P(out).<br><br>
          <img src="quadtree_build.jpg" style="width:480px;height:270px;"><br>
          In both trees create a node that corresponds to the cell c. In T(in), a result of a recursive call on P(in), it will ba a root node v(in). In T(out), a result of a recursive call on P(out), it will be a leaf node v(out). Hang the two nodes onto each other so that T(in) is a subtree of T(out): 
          <ul>
            <li>If the new node is redundant, then compress it. </li>
            <li>Otherwise, if v(out) is a compressed node, compute a new compressed node (assume this can be done in O(1)).</li>
          </ul>
          ⇒ T(|P|) = O(|P|) + T(P(in)) + T(P(out)) ⇒ <u><b>O(|P|log|P|)</b></u>
        </p>

      </div>
    </div>

        <div class="post" id="buildingWSPD">
      <h3 class="post-title"><a>Building the sWSPD from a QUADTREE</a></h3>
      <div class="post-content">
        <p> Δu = diameter of node u <br>
            Δv = diameter of node v <br>
            ▢u = set of leaves in node u <br>
            ▢v = set of leaves in node v <br>
            F = created s-WSPD <br>

            First call of the function is: WSPD(root, root)</p>

      <pre>
WSPD(u, v)
{
  if ∆u < ∆v
    swap(u, v)
  if ∆u ≤ sd(▢u,▢v)
    F = F ∪{(u,v)}
  else
    for each child w of u 
      WSPD(w, v)
}
</pre>
      </div>
    </div>

      <div class="post" id="packing">
      <h3 class="post-title"><a>Packing Argument</a></h3>
      <div class="post-content">
        <p>Algorithm uses a packing argument to divide up the nodes of the quadtree into s-WSPD. The number of circles of size Δ that are at k away from a given point is O(k^2/Δ^2) or in our case O(1/s^2)</p>
        <p> A circle packing is an arrangement of circles inside a given boundary such that no two overlap and some (or all) of them are mutually tangent. The generalization to spheres is called a sphere packing. Tessellations of regular polygons correspond to particular circle packings (Williams 1979, pp. 35-41). There is a well-developed theory of circle packing in the context of discrete conformal mapping (Stephenson). </p>
        <p> for more cool visualizations of circle packing see this link: http://lramrz.com/2017/01/circle-packing-in-processing/</p>

      <img src="http://learningfromdogs.files.wordpress.com/2010/09/dog-alpaca.png?w=700">
      </div>
    </div>
    
    
    <div class="post" id="Application">
      <h3 class="post-title"><a>Application of sWSPD on Spanners</a></h3>
      <div class="post-content">
        <p> A spanner is a small-size graph such that the shortest path distance between any two points is roughly their Euclidean distance.<br><br>
        <b>Definition.</b> A graph G = (S, E) is a ε-spanner if <br> 
        <center>∀p,q ∈ S, dG(p,q) ≤ (1+ε)∥p−q∥.</center><br> 
        <b>Theorem.</b><br> 
        ∀s>0, in two dimensional space an s-spanner on S of size O(n) can be constructed in O(nlogn + n/(s^2)) time. <br>
        <b>Proof.</b><br>
        Set δ = s/16. Construct δ-WSPD F for S. For each pair (Ai,Bi) ∈ F, choose (pi,qi) ∈ Ai×Bi.
        Let E = {(pi, qi) | 1 ≤ i ≤ |F|}. We use induction on the (n choose 2) distances to show that G = (S, E) is an s-spanner.</p>
        <img src="spanner_diagram.jpg" style="width:480px;height:270px;">
        <p> <center> dG(p, q) = dG(p, pi) + ∥pi, qi∥ + dG(q, qi)</center><br>
        By the property of δ-WSPD,<br>
        <center> ∥p−pi∥ ≤ δ∥pi − qi∥. </center><br>
        By the inductive hypothesis,<br>
        <center>dG(p,pi)≤(1+s)∥p−pi∥≤(1+s)δ∥pi−qi∥</center><br>
        Similarly, (1+s)∥q−qi∥≤(1+s)δ∥pi−qi∥. By triangle inequality,
        <br><br>
        <center>∥pi−qi∥ ≤ ∥p−q∥ + ∥p−pi∥ + ∥q−qi∥ ≤ ∥p−q∥ + 2δ∥p−q∥ = (1+2s)∥p−q∥</center><br>
        Since δ ≤ s/16 ,it can be argued that ∥p−pi∥ < ∥p−q∥. Therefore 
        <br><br>
        <center>dG(p, q) ≤ dG(p, pi) + dG(q, qi) + ∥pi − qi∥</center><br>
        <center> ≤ 2(1+s)δ∥pi − qi∥ + ∥pi − qi∥ </center><br>
        <center>≤ (1+2(1+s)δ)(1+2δ)∥p − q∥ </center><br>
        <center>dG(p, q) ≤ (1 + s) ∥p − q∥</center><br>
        <center>Q.E.D.</center></p>

      </div>
    </div>

    <div class="footer">
     Rebecca and Sofiia 
    </div>
  </div>
  </div>
</div>
  <script src='http://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js'></script>

  

</body>

</html>
